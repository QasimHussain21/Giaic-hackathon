# Data Model: In-Memory Console Todo Application

**Date**: 2026-02-06
**Phase**: 1 (Design)
**Feature**: 001-console-todo

## Overview

This document defines the data structures and entities used in the console todo application. The application uses Python dataclasses for type-safe, immutable-where-appropriate data modeling, with in-memory storage using native Python data structures.

## Entity: Task

### Description
Represents a single todo task with a unique identifier, description, completion status, and metadata.

### Attributes

| Attribute     | Type       | Required | Default         | Mutable | Description                                                        |
|---------------|------------|----------|-----------------|---------|-------------------------------------------------------------------|
| `id`          | `int`      | Yes      | Auto-generated  | No      | Unique identifier for the task (1, 2, 3, ...)                     |
| `description` | `str`      | Yes      | N/A             | Yes     | Human-readable text describing what needs to be done (1-500 chars)|
| `completed`   | `bool`     | No       | `False`         | Yes     | Whether the task has been marked as complete                       |
| `created_at`  | `datetime` | No       | `datetime.now()`| No      | Timestamp when the task was created                                |

### Validation Rules

1. **ID Validation**
   - Must be a positive integer (>= 1)
   - Automatically generated by TaskManager (sequential)
   - Immutable after creation

2. **Description Validation**
   - Cannot be empty or whitespace-only
   - Minimum length: 1 character (after stripping whitespace)
   - Maximum length: 500 characters
   - Must be valid UTF-8 string

3. **Completed Validation**
   - Must be boolean (`True` or `False`)
   - Can be toggled from incomplete → complete
   - Re-completing an already completed task is allowed (no-op)

4. **Created_at Validation**
   - Automatically set to current timestamp on creation
   - Immutable after creation
   - Timezone-naive (local time)

### Implementation

```python
from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class Task:
    """Represents a todo task.

    Attributes:
        id: Unique identifier for the task.
        description: What needs to be done.
        completed: Whether the task is marked as complete.
        created_at: When the task was created.
    """

    id: int
    description: str
    completed: bool = False
    created_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self):
        """Validate task data after initialization."""
        if self.id < 1:
            raise ValueError("Task ID must be a positive integer")
        if not self.description or not self.description.strip():
            raise ValueError("Task description cannot be empty")
        if len(self.description) > 500:
            raise ValueError("Task description must be 500 characters or less")

    def mark_complete(self) -> None:
        """Mark this task as complete."""
        self.completed = True

    def update_description(self, new_description: str) -> None:
        """Update the task description with validation.

        Args:
            new_description: The new description text.

        Raises:
            ValueError: If the new description is invalid.
        """
        if not new_description or not new_description.strip():
            raise ValueError("Task description cannot be empty")
        if len(new_description) > 500:
            raise ValueError("Task description must be 500 characters or less")
        self.description = new_description

    def __str__(self) -> str:
        """Human-readable string representation."""
        status = "✓ Done" if self.completed else "○ Todo"
        return f"[{self.id}] {self.description} ({status})"
```

### State Transitions

```
┌──────────────┐
│   Created    │
│ completed=False │
└──────┬───────┘
       │
       │ mark_complete()
       ▼
┌──────────────┐
│  Completed   │
│ completed=True │
└──────────────┘
```

**Note**: In Phase I, there is no "uncomplete" transition. Once a task is marked complete, it stays complete. Users can delete and re-add if they want to reset status.

### Entity Relationships

```
TaskManager (1) ──────── (0..*) Task
                "manages"

In-Memory Storage Structure:
┌─────────────────────────┐
│    TaskManager          │
│  ┌──────────────────┐   │
│  │ _tasks: dict     │   │
│  │  {                │   │
│  │    1: Task(id=1),│   │
│  │    2: Task(id=2),│   │
│  │    3: Task(id=3) │   │
│  │  }               │   │
│  └──────────────────┘   │
│  _next_id: int = 4      │
└─────────────────────────┘
```

**Relationship Description**:
- A `TaskManager` manages zero or more `Task` instances
- Each `Task` has exactly one `TaskManager` (no shared ownership)
- Tasks are stored in a dictionary keyed by task ID
- TaskManager maintains the next available ID counter

---

## Entity: TaskManager (Storage Container)

### Description
Manages the collection of all tasks, providing CRUD operations and maintaining in-memory state.

### Attributes

| Attribute   | Type               | Description                                    |
|-------------|--------------------|------------------------------------------------|
| `_tasks`    | `dict[int, Task]`  | Dictionary mapping task IDs to Task instances |
| `_next_id`  | `int`              | Counter for generating next task ID (starts at 1) |

### Operations

#### Create: `add_task(description: str) -> Task`
Creates a new task with the given description.

**Input**:
- `description` (str): The task description

**Output**:
- `Task`: The newly created task

**Side Effects**:
- Increments `_next_id`
- Adds task to `_tasks` dictionary

**Errors**:
- Raises `ValueError` if description is invalid

---

#### Read: `get_task(task_id: int) -> Task | None`
Retrieves a task by its ID.

**Input**:
- `task_id` (int): The task ID to retrieve

**Output**:
- `Task` if found, `None` if not found

**Side Effects**: None

---

#### Read: `get_all_tasks() -> list[Task]`
Retrieves all tasks.

**Input**: None

**Output**:
- `list[Task]`: List of all tasks (may be empty)

**Side Effects**: None

**Note**: Tasks are returned in insertion order (Python 3.7+ dict ordering guarantee)

---

#### Update: `update_task(task_id: int, new_description: str) -> bool`
Updates the description of an existing task.

**Input**:
- `task_id` (int): The ID of the task to update
- `new_description` (str): The new description

**Output**:
- `bool`: `True` if updated successfully, `False` if task not found

**Side Effects**:
- Modifies the `description` field of the task

**Errors**:
- Raises `ValueError` if new_description is invalid

---

#### Update: `mark_task_complete(task_id: int) -> bool`
Marks a task as complete.

**Input**:
- `task_id` (int): The ID of the task to mark complete

**Output**:
- `bool`: `True` if marked successfully, `False` if task not found

**Side Effects**:
- Sets `completed` field to `True`

---

#### Delete: `delete_task(task_id: int) -> bool`
Removes a task from the system.

**Input**:
- `task_id` (int): The ID of the task to delete

**Output**:
- `bool`: `True` if deleted successfully, `False` if task not found

**Side Effects**:
- Removes task from `_tasks` dictionary

**Note**: Deleted IDs are not reused (next_id continues incrementing)

---

### Implementation

```python
class TaskManager:
    """Manages a collection of tasks in memory.

    This class provides CRUD operations for tasks and maintains
    the in-memory storage of all tasks during the application session.
    """

    def __init__(self):
        """Initialize an empty task manager."""
        self._tasks: dict[int, Task] = {}
        self._next_id: int = 1

    def add_task(self, description: str) -> Task:
        """Add a new task."""
        task = Task(id=self._next_id, description=description)
        self._tasks[self._next_id] = task
        self._next_id += 1
        return task

    def get_task(self, task_id: int) -> Task | None:
        """Get a task by ID."""
        return self._tasks.get(task_id)

    def get_all_tasks(self) -> list[Task]:
        """Get all tasks."""
        return list(self._tasks.values())

    def update_task(self, task_id: int, new_description: str) -> bool:
        """Update a task's description."""
        task = self.get_task(task_id)
        if task is None:
            return False
        task.update_description(new_description)
        return True

    def mark_task_complete(self, task_id: int) -> bool:
        """Mark a task as complete."""
        task = self.get_task(task_id)
        if task is None:
            return False
        task.mark_complete()
        return True

    def delete_task(self, task_id: int) -> bool:
        """Delete a task."""
        if task_id not in self._tasks:
            return False
        del self._tasks[task_id]
        return True

    def task_count(self) -> int:
        """Return the number of tasks."""
        return len(self._tasks)
```

---

## Storage Strategy

### In-Memory Structure

**Primary Storage**: Python dictionary (`dict[int, Task]`)

**Rationale**:
- O(1) lookup by task ID
- O(1) insertion and deletion
- Maintains insertion order (Python 3.7+)
- Native Python type, no external dependencies

**Limitations**:
- Data lost when application exits
- No persistence across sessions
- Limited by available RAM (not a concern for target scale of 1-1000 tasks)

### ID Generation Strategy

**Approach**: Sequential counter starting at 1

**Rationale**:
- Simple and predictable
- No collision risk
- User-friendly IDs (1, 2, 3... instead of UUIDs)
- IDs are never reused (even after deletion)

**Implementation**:
```python
self._next_id: int = 1  # Initialize
task_id = self._next_id  # Use current
self._next_id += 1       # Increment for next
```

---

## Migration to Phase II

### Changes Required

1. **Task Entity**:
   - Convert from `@dataclass` to Pydantic `BaseModel` (or SQLModel)
   - Add user_id foreign key (for multi-user support)
   - Add updated_at timestamp
   - Add optional fields: priority, due_date, tags

2. **TaskManager**:
   - Replace in-memory dict with database queries
   - Add database session management
   - Implement repository pattern for data access
   - Add pagination for large result sets

3. **Storage**:
   - Replace `dict[int, Task]` with PostgreSQL database
   - Use SQLModel for ORM mapping
   - Add Alembic migrations for schema versioning

### Backward Compatibility

The business logic in `TaskManager` will remain largely the same - only the storage backend changes. This design enables smooth Phase II migration.

---

## Testing Considerations

### Unit Tests for Task

- Test task creation with valid data
- Test task creation with invalid data (empty description, too long, negative ID)
- Test mark_complete() changes status
- Test update_description() with valid and invalid data
- Test string representation (__str__)

### Unit Tests for TaskManager

- Test add_task creates task and increments ID
- Test get_task returns correct task or None
- Test get_all_tasks returns all tasks in order
- Test update_task with existing and non-existing IDs
- Test mark_task_complete with existing and non-existing IDs
- Test delete_task with existing and non-existing IDs
- Test task_count returns correct count

### Integration Tests

- Full CRUD flow: add → get → update → mark complete → delete
- Multiple tasks with different states
- Empty list handling





